import io
import os
import typing
import zipfile
from collections import OrderedDict
from datetime import date, datetime
from typing import Any
from urllib.parse import quote

from django.conf import settings
from django.contrib import admin
from django.http import HttpResponse
from django.shortcuts import redirect
from django.urls import path, reverse
from django.utils.translation import gettext
from django.utils.translation import gettext_lazy as _
from reportlab.lib import colors
from reportlab.lib.colors import HexColor
from reportlab.lib.enums import TA_CENTER, TA_LEFT, TA_RIGHT
from reportlab.lib.pagesizes import A4, mm  # type: ignore
from reportlab.lib.styles import ParagraphStyle, getSampleStyleSheet
from reportlab.platypus import Image, Paragraph, Table, TableStyle


@admin.action(description=_("Generate PDF for selected rows"))
def generate_pdf_selected(modeladmin, request, queryset):
    """
    Admin action to generate PDF files for selected rows.

    This function serves as a Django admin action that allows users to select
    multiple rows from the admin changelist and generate PDF files for them.
    The actual PDF generation is delegated to the ModelAdmin's generate_pdf method.

    Args:
        modeladmin: The ModelAdmin instance that provides PDF generation functionality
        request: The HttpRequest object containing request information
        queryset: QuerySet containing the selected model instances for PDF generation

    Returns:
        HttpResponse: PDF file download response (single PDF) or ZIP file download
                     response (multiple PDFs) generated by the ModelAdmin's generate_pdf method

    Note:
        This function relies on the ModelAdmin having a generate_pdf method available,
        typically provided by the BasePdfMixin.
    """
    return modeladmin.generate_pdf(request, queryset)


class BasePdfMixin:
    """
    Mixin class that provides PDF generation functionality for Django ModelAdmin classes.

    This mixin adds comprehensive PDF generation capabilities to Django admin interfaces,
    including single PDF downloads and bulk ZIP file creation with multiple PDFs.
    It provides a foundation for creating Japanese-compatible PDF documents using ReportLab
    with predefined styling, fonts, and layout configurations.

    Features:
        - Japanese font support (IPA and Noto Sans JP fonts)
        - Configurable page layout and margins
        - Table creation with customizable styling
        - Single PDF or ZIP file downloads
        - Admin action integration
        - Automatic file naming with timestamps

    Attributes:
        Font Configuration:
            regular_font (str): Default font for regular text
            bold_font (str): Font for bold text
            thin_font (str): Font for thin text

        Font Sizes:
            title_font_size (int): Size for titles (14pt)
            sub_title_font_size (int): Size for subtitles (12pt)
            normal_font_size (int): Size for normal text (10pt)
            subscript_font_size (int): Size for small text (8pt)

        Page Layout:
            page_size: Paper size (A4)
            page_margin_left/right/top/bottom: Page margins in mm

        Styling:
            cell_label_bg_color: Background color for table headers

    Abstract Methods:
        create_pdf_files(request, queryset): Must be implemented by subclasses
                                           to define specific PDF generation logic

    Usage:
        ```python
        class MyModelAdmin(BasePdfMixin, admin.ModelAdmin):
            def create_pdf_files(self, request, queryset):
                # Implement PDF creation logic
                return ['file1.pdf', 'file2.pdf']
        ```

    Note:
        This mixin overrides several ModelAdmin methods (get_urls, get_actions,
        changelist_view) to integrate PDF functionality. Ensure proper method
        resolution order when using with other mixins.
    """

    # regular_font = "NotoSansJP-Regular"
    regular_font = "ipaexm"
    bold_font = "NotoSansJP-Bold"
    thin_font = "NotoSansJP-Thin"
    title_font_size = 14
    sub_title_font_size = 12
    normal_font_size = 10
    subscript_font_size = 8

    page_size = A4
    page_margin_left = 20 * mm
    page_margin_right = 20 * mm
    page_margin_top = 20 * mm
    page_margin_bottom = 20 * mm

    cell_label_bg_color = HexColor("#CAEBAA")

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        opts = self.model._meta  # type: ignore[attr-defined]
        self.pdf_url_name = f"{opts.app_label}_{opts.model_name}_generate_pdf"  # type: ignore

    def get_default_styles(self):
        styles = getSampleStyleSheet()
        styles["Normal"].fontName = self.regular_font
        styles["Normal"].fontSize = self.normal_font_size
        styles["Normal"].leading = 12
        styles["Title"].fontName = self.bold_font
        styles["Title"].fontSize = self.title_font_size
        styles["Title"].leading = 17
        styles["Title"].fontWeight = "bold"
        styles["Heading1"].fontName = self.bold_font
        styles["Heading1"].fontSize = self.title_font_size
        styles["Heading1"].leading = 17
        styles["Heading1"].fontWeight = "bold"
        styles["Heading2"].fontName = self.bold_font
        styles["Heading2"].fontSize = self.sub_title_font_size
        styles["Heading2"].leading = 15
        styles["Heading2"].fontWeight = "bold"
        styles["Heading3"].fontName = self.bold_font
        styles["Heading3"].fontSize = self.normal_font_size
        styles["Heading3"].leading = 12
        styles["Heading3"].fontWeight = "bold"

        styles.add(ParagraphStyle(name="NormalLabel", parent=styles["Heading3"], alignment=TA_CENTER))
        styles.add(ParagraphStyle(name="NormalCenter", parent=styles["Normal"], alignment=TA_CENTER))
        styles.add(ParagraphStyle(name="NormalRight", parent=styles["Normal"], alignment=TA_RIGHT))

        styles.add(ParagraphStyle(name="CellLabel", parent=styles["Heading3"], alignment=TA_CENTER))
        styles.add(ParagraphStyle(name="Cell", parent=styles["Normal"], alignment=TA_LEFT))
        styles.add(ParagraphStyle(name="CellCenter", parent=styles["Normal"], alignment=TA_CENTER))
        styles.add(ParagraphStyle(name="CellRight", parent=styles["Normal"], alignment=TA_RIGHT))

        styles.add(ParagraphStyle(name="UnderlineHeading1", parent=styles["Heading1"], underline=1, alignment=TA_CENTER))
        styles.add(ParagraphStyle(name="Subscript", fontName=self.thin_font, fontSize=9, leading=6, alignment=TA_LEFT))
        return styles

    def get_table_style(self, has_grid=True, extra_styles=None):
        """
        Create a ReportLab TableStyle object with default formatting.

        Generates a standardized table style for PDF tables with consistent
        alignment, padding, and optional grid lines. Additional custom styles
        can be applied on top of the base configuration.

        Args:
            has_grid (bool, optional): Whether to add grid lines and borders.
                                     Defaults to True.
            extra_styles (list, optional): List of additional style tuples to apply.
                                         Each tuple should follow ReportLab TableStyle format:
                                         (command, start_cell, end_cell, *args)

        Returns:
            TableStyle: Configured ReportLab TableStyle object ready for use with Table objects.

        Base Styles Applied:
            - LEFT alignment for all cells
            - MIDDLE vertical alignment
            - 2mm bottom padding
            - Optional 0.5pt grid lines (if has_grid=True)
            - Optional 1pt border box (if has_grid=True)

        Example:
            ```python
            # Basic table with grid
            style = self.get_table_style()

            # Table without grid lines
            style = self.get_table_style(has_grid=False)

            # Table with custom background color for header row
            extra = [('BACKGROUND', (0, 0), (-1, 0), colors.lightgrey)]
            style = self.get_table_style(extra_styles=extra)
            ```
        """
        table_style = TableStyle(
            [
                ("ALIGN", (0, 0), (-1, -1), "LEFT"),
                ("VALIGN", (0, 0), (-1, -1), "MIDDLE"),
                ("BOTTOMPADDING", (0, 0), (-1, -1), 2 * mm),
            ]
        )

        if has_grid:
            table_style.add("GRID", (0, 0), (-1, -1), 0.5, "black")
            table_style.add("BOX", (0, 0), (-1, -1), 1, "black")

        if extra_styles:
            for extra in extra_styles:
                table_style.add(*extra)

        return table_style

    def create_table(self, data, colWidths, hAlign="LEFT", table_style=None, repeatRows=1):
        """
        Create a ReportLab Table object from data with proper formatting.

        Converts raw data into a formatted ReportLab Table with automatic text
        styling, support for various cell content types, and configurable layout options.
        Handles empty data gracefully by creating a minimal table with empty content.

        Args:
            data (list): 2D list of table data. Each row is a list of cells.
                        Cell content can be:
                        - str: Plain text (styled with Normal style)
                        - tuple: (text, style_name) for custom styling
                        - Paragraph: Pre-formatted ReportLab Paragraph object
                        - Image: ReportLab Image object
                        Empty data is handled by creating a minimal table with empty content.
            colWidths (list): List of column widths in ReportLab units (e.g., mm).
                            If empty and data is also empty, defaults to [50*mm].
            hAlign (str, optional): Horizontal alignment of the table. Defaults to "LEFT".
                                   Options: "LEFT", "CENTER", "RIGHT"
            table_style (TableStyle, optional): Custom table style. If None, uses
                                              get_table_style() default.
            repeatRows (int, optional): Number of header rows to repeat on each page.
                                       Defaults to 1.

        Returns:
            Table: Configured ReportLab Table object ready for PDF document inclusion.
                  For empty data, returns a minimal table with one empty cell.

        Raises:
            ValueError: If cell data is not a supported type (str, tuple, Paragraph, Image).

        Note:
            This method requires get_invoice_styles() method to be available,
            which should return a dictionary of paragraph styles.

        Example:
            ```python
            data = [
                [('Header 1', 'Bold'), ('Header 2', 'Bold')],
                ['Cell 1', 'Cell 2'],
                [('Total', 'Bold'), '¥1,000']
            ]
            colWidths = [50*mm, 30*mm]
            table = self.create_table(data, colWidths)

            # Empty data handling
            empty_table = self.create_table([], [])  # Creates minimal table
            ```
        """
        styles = self.get_default_styles()
        table_data = []

        # Handle empty data case - ReportLab requires at least one row and column
        if not data or not any(data):
            # Create minimal table with empty cell if no data provided
            if not colWidths:
                colWidths = [50 * mm]  # Default width for empty table
            table_data = [[Paragraph("", styles["Normal"])]]
        else:
            for row in data:
                table_row = []
                for cell in row:
                    if isinstance(cell, tuple):
                        table_row.append(Paragraph(cell[0], styles[cell[1]]))
                    else:
                        if isinstance(cell, str):
                            table_row.append(Paragraph(cell, styles["Normal"]))
                        elif isinstance(cell, Paragraph):
                            table_row.append(cell)
                        elif isinstance(cell, Image):
                            table_row.append(cell)
                        else:
                            table_row.append(Paragraph(str(cell), styles["Normal"]))
                table_data.append(table_row)

        if table_style is None:
            table_style = self.get_table_style()
        table = Table(table_data, colWidths=colWidths, hAlign=hAlign, style=table_style, repeatRows=repeatRows)  # type: ignore
        return table

    def get_pdf_temporary_path(self):
        """
        Get the temporary directory path for storing generated PDF files.

        Returns:
            str: Directory path where temporary PDF files should be stored.
                Uses Django's TEMP_DIR setting.

        Note:
            The returned directory should exist and be writable. PDF files
            created in this directory are typically temporary and may be
            cleaned up after download.
        """
        return settings.TEMP_DIR

    def get_zip_file_name(self, request, queryset=None, name=None) -> str:
        """
        Generate a ZIP filename for multiple PDF downloads.

        Creates a properly formatted filename for ZIP archives containing
        multiple PDF files, including a timestamp to ensure uniqueness.

        Args:
            request: The HttpRequest object (currently unused but kept for consistency)
            queryset (QuerySet, optional): The queryset being processed (currently unused)
            name (str, optional): Custom name to use instead of model verbose_name.
                                 If None, uses the model's verbose_name.

        Returns:
            str: A formatted ZIP filename in the pattern:
                 "{name}_{YYYYMMDD_HHMMSS}.zip"

        Example:
            If model verbose_name is "請求書" and current time is 2024-01-15 14:30:45:
            Returns: "請求書_20240115_143045.zip"
        """
        current_datetime = datetime.now().strftime("%Y%m%d_%H%M%S")
        # ファイル名を日本語にする場合はurlencodeが必要
        quoted_name = name if name else self.model._meta.verbose_name  # type: ignore
        return f"{quoted_name}_{current_datetime}.zip"

    @typing.no_type_check
    def generate_pdf(self, request, queryset=None):
        """
        Generate PDF files for the given queryset and return as HTTP response.

        This is the main method that orchestrates PDF generation. It handles both
        single PDF downloads and multiple PDF downloads packaged in a ZIP file.
        If no queryset is provided, it uses the current changelist queryset with
        all applied filters and search terms.

        Args:
            request: The HttpRequest object containing request information
            queryset (QuerySet, optional): Specific queryset to process. If None,
                                          uses the changelist queryset with filters applied.

        Returns:
            HttpResponse: Either a PDF file download response (single PDF) or
                         ZIP file download response (multiple PDFs), or
                         redirect response with warning message if no data exists.

        Process Flow:
            1. Get queryset (provided or from changelist with filters)
            2. Check if queryset has data
            3. Call create_pdf_files() to generate PDF files
            4. If single PDF: return PDF download response
            5. If multiple PDFs: create ZIP archive and return ZIP download response
            6. Handle edge cases with appropriate user messages

        Note:
            This method depends on the abstract create_pdf_files() method which
            must be implemented by subclasses to define the actual PDF generation logic.
        """
        if queryset is None:
            ChangeListClass = self.get_changelist(request)
            cl = ChangeListClass(
                request,
                self.model,
                self.list_display,
                self.list_display_links,
                self.list_filter,
                self.date_hierarchy,
                self.search_fields,
                self.list_select_related,
                self.list_per_page,
                self.list_max_show_all,
                self.list_editable,
                self,
                sortable_by=self.get_sortable_by(request),
                search_help_text=self.search_help_text,
            )

            queryset = cl.get_queryset(request)

        if not queryset.exists():
            self.message_user(request, _("No data available for PDF generation."), level="warning")
            return redirect(request.get_full_path())

        pdf_files = self.create_pdf_files(request, queryset)
        pdf_count = len(pdf_files)
        if pdf_count == 0:
            self.message_user(
                request,
                _("No PDFs were created. Please check the related data."),
                level="warning",
            )
            return
        if pdf_count == 1:
            filename = pdf_files[0]
            with open(os.path.join(self.get_pdf_temporary_path(), filename), "rb") as f:
                file_data = f.read()
            file = io.BytesIO(file_data)
            response = HttpResponse(file, content_type="application/pdf")
        else:
            zip_buffer = io.BytesIO()
            with zipfile.ZipFile(zip_buffer, "w", zipfile.ZIP_DEFLATED) as zip_file:
                for pdf_file in pdf_files:
                    zip_file.write(os.path.join(self.get_pdf_temporary_path(), pdf_file), arcname=pdf_file)
            zip_buffer.seek(0)
            response = HttpResponse(zip_buffer, content_type="application/zip")
            filename = self.get_zip_file_name(request, queryset)

        response["Content-Disposition"] = f"attachment; filename=\"{quote(filename)}\"; filename*=UTF-8''{quote(filename)}"
        return response

    def write_page_header(self, canvas_obj, doc_obj):
        """
        Write page header with issue date and page number.

        Args:
            canvas_obj: ReportLab Canvas object for drawing
            doc_obj: Document object containing page layout information
        """
        canvas_obj.saveState()

        # Set font and color
        canvas_obj.setFont(self.regular_font, self.normal_font_size)
        canvas_obj.setFillColor(colors.black)

        # Header text, right-aligned
        issue_date = gettext("Issue Date: %s") % date.today().strftime("%Y-%m-%d")
        page_num = gettext("Page: %s") % canvas_obj.getPageNumber()
        x = self.page_size[0] - doc_obj.leftMargin
        y = doc_obj.height + doc_obj.bottomMargin + 10 * mm
        canvas_obj.drawRightString(x, y, issue_date)
        canvas_obj.drawRightString(x, y - 5 * mm, page_num)

        canvas_obj.restoreState()

    def create_pdf_files(self, request, queryset):
        """
        Abstract method for creating PDF files from the given queryset.

        This method must be implemented by subclasses to define the specific
        PDF generation logic for each model. It should create one or more PDF
        files and save them to the temporary directory.

        Args:
            request: The HttpRequest object containing request information
            queryset (QuerySet, optional): The queryset to process for PDF generation

        Returns:
            list[str]: List of PDF filenames that were created in the temporary directory.
                      These files should exist in the path returned by get_pdf_temporary_path().

        Raises:
            NotImplementedError: Always raised if not overridden in subclass.

        Implementation Notes:
            - Generate PDF files using ReportLab or similar library
            - Save files to the directory returned by get_pdf_temporary_path()
            - Return list of filenames (not full paths)
            - Handle Japanese text encoding properly
            - Consider memory usage for large querysets

        Example:
            ```python
            def create_pdf_files(self, request, queryset):
                pdf_files = []
                for obj in queryset:
                    filename = f"{obj.id}.pdf"
                    # Create PDF content and save to temp directory
                    pdf_files.append(filename)
                return pdf_files
            ```
        """
        raise NotImplementedError("create_pdf_files() must be implemented in the subclass.")

    def get_urls(self):
        """
        Override the default ModelAdmin URLs to include a custom PDF generation endpoint.

        Adds a custom URL pattern for PDF generation functionality while preserving
        all existing admin URLs. The PDF generation URL is accessible to admin users
        and respects the same permissions as the changelist view.

        Returns:
            list: Combined list of custom PDF URLs and default admin URLs,
                 with custom URLs taking precedence.

        URL Pattern:
            - Path: "generate_pdf/"
            - Name: "{app_label}_{model_name}_generate_pdf"
            - View: Protected by admin_site.admin_view wrapper

        Note:
            Custom URLs are placed before default URLs to ensure they take
            precedence in URL resolution.
        """
        urls = super().get_urls()  # type: ignore
        generate_pdf_url = [
            path(
                "generate_pdf/",
                self.admin_site.admin_view(self.generate_pdf),  # type: ignore
                name=self.pdf_url_name,
            ),
        ]
        return generate_pdf_url + urls

    def get_actions(self, request) -> OrderedDict[Any, Any]:
        """
        Add PDF generation action to the list of available admin actions.

        Extends the default admin actions with a custom "generate_pdf_selected" action
        that allows users to generate PDF files for selected rows from the changelist.

        Args:
            request: The HttpRequest object containing request information

        Returns:
            dict: Dictionary of available actions including the new PDF generation action.
                 Format: {action_name: (function, name, description)}

        Action Details:
            - Key: "generate_pdf_selected"
            - Function: generate_pdf_selected function from this module
            - Description: Localized Japanese text "選択行のPDF作成"

        Note:
            The PDF generation action will appear in the admin changelist action dropdown
            and can be applied to any selected rows.
        """
        actions = super().get_actions(request)  # type: ignore
        # Handle case where parent returns None
        if actions is None:
            actions = {}
        actions["generate_pdf_selected"] = (
            generate_pdf_selected,
            "generate_pdf_selected",
            generate_pdf_selected.short_description,  # type: ignore
        )
        return actions

    def changelist_view(self, request, extra_context=None):
        """
        Override the changelist view to add PDF generation button and functionality.

        Enhances the default admin changelist view by adding context variables
        needed to display a PDF generation button and handle PDF creation functionality.
        The PDF generation URL preserves any applied filters, search terms, or sorting.

        Args:
            request: The HttpRequest object containing request information
            extra_context (dict, optional): Additional context data for the template

        Returns:
            TemplateResponse: The changelist view response with additional
                            PDF generation-related context variables.

        Context Variables Added:
            - generate_pdf_url: URL for PDF generation with current filters/search preserved
            - generate_pdf_button_name: Localized button text for PDF generation

        Note:
            The PDF generation URL includes any GET parameters from the current request
            to ensure that filters, search terms, and sorting are preserved in
            the generated PDFs.
        """
        if extra_context is None:
            extra_context = {}

        url = reverse(f"{self.admin_site.name}:{self.pdf_url_name}")  # type: ignore
        params = request.GET.urlencode()
        if params:
            url = f"{url}?{params}"

        extra_context["generate_pdf_url"] = url
        extra_context["pdf_title"] = _("Generate {model_name} PDF").format(model_name=self.model._meta.verbose_name)  # type: ignore
        extra_context["pdf_message"] = _("Are you sure you want to generate the PDF file?")
        extra_context["pdf_button"] = _("Generate PDF")
        return super().changelist_view(request, extra_context=extra_context)  # type: ignore
